%
% Error API
%
\chapter{Error Handling}
\label{chp-error}

Within the \lname, Error handling has two aspects: One for communicating
error conditions out of the framework and back to applications; the other for
handling error signals from the environment and operating system. Classes
and other code to implement error processing are described in this chapter.

\section{Biometric Evaluation Exceptions}
The \lname\ contains a set of classes used to report errors to applications.
Objects of these class types are thrown and contain descriptive information as
to the nature of the error. Applications must handle the errors in a manner
that makes sense for the application.

Applications should catch objects of the type specified in the API for the
class being called. The type of object caught indicates the nature of the
error that occurred, while the string stored within that object
provides more information on the error.

\lstref{logcabinetuse} shows an example of exception handling when using
the logging classes described in \secref{sec-logging}.

\section{Signal Handling}
\label{sec-signalhandling}

When the application process executes in a POSIX environment, signals to the
process can be generated by the operating system. In many cases, if the
signal is not handled by the process, execution terminates. Because the
\lname\ was designed to used with software libraries for which no source code
is available, changes to the code in these libraries cannot be made, and any
faults in that code cannot be fixed. A common problem is that a function in
the ``black box'' library dereferences a bad pointer, resulting in a
segmentation violation signal being sent by the operating system.

To prevent termination of the application process, signal handling must be
installed. The \lname\ provides a class, {\em SignalManager}, to simplify
the installation of a signal handler in order to allow the program to
continue running. For example, when extracting a fingerprint minutia template
from an image, often the library call will fault on a certain image. By using
the {\em SignalManager}, the application can log that fault, and continue on
to the next image.

Signal handling in a POSIX environment covers the bare essentials, and one of
two actions is usually taken. The signal can be handled and processing
continues at the location the signal was generated. The second action is
that, in addition to signal handling, the process continues from a different
location. It is the second action that is implemented by the
{\em SignalManager} class. The rationale for this type of signal handling is
so the call to the faulting function can be aborted, but the caller can
detect that the signal was handled and take action, usually by logging the
fault.

By default, the {\em SignalManager} class installs a handler for the
{\tt SIGSEGV} and {\tt SIGBUS} signals. However, other signals can be
handled as desired.

One restriction on the use of {\em SignalManager} is that the POSIX calls for
signal management ({\em signal(3)}, {\em sigaction(2)}, etc.) cannot be
invoked inside of the signal handler block.

The example in \lstref{signalmanageruse} shows application use of the
{\em SignalManager} class.

\lstset{language=c++}
\begin{lstlisting}[caption={Using the SignalManger}, label=signalmanageruse]
#include <be_error_signal_manager.h>
using namespace BiometricEvaluation;

int main(int argc, char *argv[])
{
	Error::SignalManager *sigmgr = new Error::SignalManager();

	BEGIN_SIGNAL_BLOCK(sigmgr, sigblock1);
	// code that may result in signal generation
	END_SIGNAL_BLOCK(asigmgr, sigblock1);
	if (sigmgr->sigHandled()) {
		// log the event, etc.
	}
}
\end{lstlisting}

Within the {\em SignalManager} header file, two macros are defined:
{\tt BEGIN\_SIGNAL\_BLOCK()} and {\tt END\_SIGNAL\_BLOCK()}, each taking the
{\em SignalManager} object and label as parameters. The label must be unique
for each signal block. These macros insert the
jump buffer into the code, which is the location where the signal handler will
jump to after handling the signal. The use of these macros greatly simplifies
signal handling for the application, and it is recommended that applications
use these macros instead of directly invoking the methods of the
{\em SignalManger} class, except for changing the set of handled signals.

If a signal does occur, process control jumps to the end of the signal block,
and the sigHandled() method of the signal manager can be called. The
application may need to have the same statements inside the sigHandled() check
as those outside of the signal handling block. For example, if a file needs
to be closed before the end of the block, the same call to the close function
must be made within the sigHandled() check. Careful application design can
reduce the amount of code replication, however.

\lstref{signalmanageruse2} shows how an application can indicate what
signals to handle. In this example, only the {\tt SIGUSR1} signal would
be handled.

\lstset{language=c++}
\begin{lstlisting}[caption={Specifying Signals to the SignalManger}, label=signalmanageruse2]
#include <be_error_signal_manager.h>
using namespace BiometricEvaluation;

int main(int argc, char *argv[])
{
    Error::SignalManager *sigmgr = new Error::SignalManager();

    sigset_t sigset;
    sigemptyset(&sigset);
    sigaddset(&sigset, SIGUSR1);
    sigmgr->setSignalSet(sigset);

    FILE *fp = fopen( ... );
    BEGIN_SIGNAL_BLOCK(sigmgr, sigblock2);
        // code that may result in signal generation
        fclose(fp);
    END_SIGNAL_BLOCK(asigmgr, sigblock2);
    if (sigmgr->sigHandled()) {
        cout << "SIGUSR1 occurred." << endl;
        fclose(fp);
    }
}
\end{lstlisting}
